CREATE TABLE Cluster(
    ID SERIAL PRIMARY KEY NOT NULL,
    CountRate INTEGER,
    SummaRate INTEGER
);

CREATE TABLE Person(
    ID SERIAL PRIMARY KEY NOT NULL,
    ClusterID INTEGER,
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID)
);

CREATE TABLE Song(
    ID Serial PRIMARY KEY not null
);

CREATE TABLE RatePerson(
    PersonID INTEGER NOT NULL ,
    SongID INTEGER NOT NULL ,
    Value SMALLINT CHECK (Value >= 0 AND Value <= 5),
    PRIMARY KEY (PersonID, SongID),
    FOREIGN KEY (PersonID) REFERENCES Person(ID),
    FOREIGN KEY (SongID) REFERENCES Song(ID)
);

CREATE TABLE RateCluster(
    ClusterID INTEGER NOT NULL ,
    SongID INTEGER NOT NULL ,
    Value SMALLINT CHECK (Value >= 0 AND Value <=5),
    PRIMARY KEY (ClusterID, SongID),
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID),
    FOREIGN KEY (SongID) REFERENCES Song(ID)
);

CREATE TABLE PersonPredicate(
    PersonID INTEGER NOT NULL ,
    Value NUMERIC,
    PRIMARY KEY (PersonID),
    FOREIGN KEY (PersonID) REFERENCES Person(ID)
);

CREATE TABLE SongPredicate(
    SongID INTEGER NOT NULL ,
    ClusterID INTEGER NOT NULL ,
    Value NUMERIC,
    PRIMARY KEY (SongID, ClusterID),
    FOREIGN KEY (SongID) REFERENCES Song(ID),
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID)
);

CREATE TABLE PersonInfo(
    PersonId INTEGER UNIQUE NOT NULL ,
    Name VARCHAR(45) UNIQUE,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    Password VARCHAR(45),
    PRIMARY KEY (PersonId),
    FOREIGN KEY (PersonId) REFERENCES Person(ID)
);

CREATE TABLE SongInfo (
    SongId INTEGER UNIQUE NOT NULL ,
    Name VARCHAR(30),
    PRIMARY KEY (SongId),
    FOREIGN KEY (SongId) REFERENCES Song(ID)
);

CREATE OR REPLACE FUNCTION OperationPerson() RETURNS TRIGGER as $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO PersonInfo(PersonId, Name) VALUES (NEW.ID, null);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE from PersonInfo where PersonId = OLD.ID;
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER InsertPerson
    AFTER INSERT on Person
    FOR EACH ROW
    EXECUTE PROCEDURE OperationPerson();

CREATE TRIGGER DeletePerson
    BEFORE DELETE on Person
    FOR EACH ROW
    EXECUTE PROCEDURE OperationPerson();

CREATE OR REPLACE FUNCTION OperationSong() RETURNS TRIGGER as $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO SongInfo(SongId, Name) VALUES (NEW.ID, 'empty');
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE from SongInfo where SongId = OLD.ID;
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER InsertSong
    AFTER INSERT on Song
    FOR EACH ROW
    EXECUTE PROCEDURE OperationSong();

CREATE TRIGGER DeleteSong
    BEFORE DELETE on Song
    FOR EACH ROW
    EXECUTE PROCEDURE OperationSong();

CREATE TABLE PersonRoles (
  UserRoleID SERIAL PRIMARY KEY NOT NULL ,
  name VARCHAR(45) NOT NULL,
  ROLE VARCHAR(45) NOT NULL,
  CONSTRAINT doubleKey UNIQUE (name, ROLE) ,
  FOREIGN KEY (name) REFERENCES personinfo (name)
);