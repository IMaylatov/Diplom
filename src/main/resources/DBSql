CREATE TABLE Cluster(
    ID SERIAL PRIMARY KEY NOT NULL,
    CountRate INTEGER,
    SummaRate INTEGER
);

CREATE TABLE Person(
    ID SERIAL PRIMARY KEY NOT NULL,
    ClusterID INTEGER,
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID)
);

CREATE TABLE Song(
    ID Serial PRIMARY KEY not null
);

CREATE TABLE RatePerson(
    PersonID INTEGER NOT NULL ,
    SongID INTEGER NOT NULL ,
    Value SMALLINT CHECK (Value >= 0 AND Value <= 5),
    PRIMARY KEY (PersonID, SongID),
    FOREIGN KEY (PersonID) REFERENCES Person(ID),
    FOREIGN KEY (SongID) REFERENCES Song(ID)
);

CREATE TABLE RateCluster(
    ClusterID INTEGER NOT NULL ,
    SongID INTEGER NOT NULL ,
    Value SMALLINT CHECK (Value >= 0 AND Value <=5),
    PRIMARY KEY (ClusterID, SongID),
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID),
    FOREIGN KEY (SongID) REFERENCES Song(ID)
);

CREATE TABLE PersonPredicate(
    PersonID INTEGER NOT NULL ,
    Value NUMERIC,
    PRIMARY KEY (PersonID),
    FOREIGN KEY (PersonID) REFERENCES Person(ID)
);

CREATE TABLE SongPredicate(
    SongID INTEGER NOT NULL ,
    ClusterID INTEGER NOT NULL ,
    Value NUMERIC,
    PRIMARY KEY (SongID, ClusterID),
    FOREIGN KEY (SongID) REFERENCES Song(ID),
    FOREIGN KEY (ClusterID) REFERENCES Cluster(ID)
);

CREATE TABLE PersonInfo(
    PersonId INTEGER UNIQUE NOT NULL ,
    Name VARCHAR(45) UNIQUE,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    Password VARCHAR(45),
    PRIMARY KEY (PersonId),
    FOREIGN KEY (PersonId) REFERENCES Person(ID)
);

CREATE TABLE SongInfo (
    SongId INTEGER UNIQUE NOT NULL ,
    Name VARCHAR(30),
    AuthorSongId INTEGER,
    PRIMARY KEY (SongId),
    FOREIGN KEY (SongId) REFERENCES Song(ID),
    FOREIGN KEY (AuthorSongId) REFERENCES AuthorSong(id)
);

CREATE OR REPLACE FUNCTION OperationPerson() RETURNS TRIGGER as $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO PersonInfo(PersonId, Name) VALUES (NEW.ID, null);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE from PersonInfo where PersonId = OLD.ID;
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER InsertPerson
    AFTER INSERT on Person
    FOR EACH ROW
    EXECUTE PROCEDURE OperationPerson();

CREATE TRIGGER DeletePerson
    BEFORE DELETE on Person
    FOR EACH ROW
    EXECUTE PROCEDURE OperationPerson();

CREATE OR REPLACE FUNCTION OperationSong() RETURNS TRIGGER as $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO SongInfo(SongId, Name) VALUES (NEW.ID, 'empty');
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE from SongInfo where SongId = OLD.ID;
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER InsertSong
    AFTER INSERT on Song
    FOR EACH ROW
    EXECUTE PROCEDURE OperationSong();

CREATE TRIGGER DeleteSong
    BEFORE DELETE on Song
    FOR EACH ROW
    EXECUTE PROCEDURE OperationSong();

CREATE TABLE PersonRoles (
  PersonInfoID INTEGER NOT NULL ,
  ROLE VARCHAR(45) NOT NULL,
  PRIMARY KEY (PersonInfoID, ROLE),
  FOREIGN KEY (PersonInfoID) REFERENCES personinfo (PersonId)
);

CREATE TABLE PersonHistory(
  Id SERIAL PRIMARY KEY NOT NULL ,
  PersonId INTEGER NOT NULL,
  SongId INTEGER NOT NULL ,
  Date TIMESTAMP NOT NULL ,
  FOREIGN KEY (PersonId) REFERENCES Person(Id),
  FOREIGN KEY (SongId) REFERENCES Song(Id)
);

CREATE TABLE AuthorSong(
  Id SERIAL PRIMARY KEY NOT NULL ,
  Name VARCHAR(100) not NULL DEFAULT 'empty'
);

CREATE TABLE Genre(
  Id SERIAL PRIMARY KEY NOT NULL ,
  NAME VARCHAR(100) NOT NULL DEFAULT 'empty'
);

CREATE TABLE AuthorSongGenre(
  GenreId INTEGER NOT NULL ,
  AuthorSongId INTEGER NOT NULL ,
  PRIMARY KEY (GenreId, AuthorSongId),
  FOREIGN KEY (GenreId) REFERENCES Genre(id),
  FOREIGN KEY (AuthorSongId) REFERENCES AuthorSong(Id)
);

CREATE TABLE BlackList(
    PersonId INTEGER NOT NULL ,
    SongID INTEGER NOT NULL ,
    PRIMARY KEY (PersonId, SongID),
    FOREIGN KEY (PersonId) REFERENCES Person(ID),
    FOREIGN KEY (SongID) REFERENCES Song(ID)
);